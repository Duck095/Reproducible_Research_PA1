---
title: "Lab Tranformer -DPLYR"
output:
  pdf_document: default
  html_notebook: default
Design: Huynx23
---


# Bài Lab: Tranformer -DPLYR

## Mục tiêu học tập
Sau khi hoàn thành bài lab này, sinh viên sẽ có khả năng:
- Sử dụng các hàm cơ bản của dplyr để biến đổi dữ liệu
- Áp dụng các phép lọc, sắp xếp, chọn cột và tạo biến mới
- Thực hiện các phép tính thống kê cơ bản trên nhóm dữ liệu
- Giải quyết các bài toán thực tế trong phân tích dữ liệu hàng không


```{r}
# Chuẩn bị thư viện
library(nycflights13)
library(tidyverse)
library(lubridate)
```


```{r}
# Kiểm tra dữ liệu
head(flights)
glimpse(flights)
```


## Phần 1: Lọc dữ liệu với filter()

### Lý thuyết
Hàm `filter()` cho phép chúng ta lọc các dòng dữ liệu dựa trên điều kiện. Các toán tử logic thường dùng:
- `>`, `>=`, `<`, `<=`: so sánh số học
- `==`: bằng nhau (chính xác)
- `!=`: không bằng nhau
- `&` hoặc `,`: phép VÀ (AND)
- `|`: phép HOẶC (OR)
- `!`: phép PHỦ ĐỊNH (NOT)
- `%in%`: kiểm tra thuộc tập hợp


### Bài tập 1.1: Phân tích độ trễ chuyến bay
**Tình huống thực tế**: Bạn là nhà phân tích dữ liệu cho một công ty du lịch. Khách hàng thường hỏi về tình trình độ trễ của các chuyến bay để lập kế hoạch.

Hãy tìm tất cả các chuyến bay thỏa mãn các điều kiện sau:

1. **Chuyến bay bị trễ đến >= 2 giờ**
   - Giải thích: `arr_delay` được tính bằng phút, vậy 2 giờ = 120

```{r}
# 1. Chuyến bay bị trễ đến >= 2 giờ (120 phút)
cat("1. Chuyến bay trễ đến >= 2 giờ:\n")
flights_delay_2h <- flights %>% filter(!is.na(arr_delay), arr_delay >= 120)
cat("Số chuyến bay trễ >= 2 giờ:", nrow(flights_delay_2h), "\n")
cat("Tỷ lệ:",round(nrow(flights_delay_2h) / nrow(flights) * 100, 2), "%\n\n")
```
2. **Chuyến bay đi Houston (IAH hoặc HOU)** Sử dụng %in% để code gọn gàng hơn

   
```{r}
# 2. Chuyến bay đi Houston
cat("2. Chuyến bay đi Houston:\n")
flights_houston_v1 <- flights %>% filter(dest %in% c("IAH","HOU"))
flights_houston_v2 <- filter(flights, dest == "IAH" | dest == "HOU")
# In kết quả V1
cat("Số chuyến bay đi Houston:", nrow(flights_houston_v1), "\n")
# In kết quả V2
cat("Số chuyến bay đi Houston:", nrow(flights_houston_v2), "\n")
# So sánh 2 cách code v1 và v2
cat("Kết quả giống nhau:", identical(flights_houston_v1, flights_houston_v2), "\n\n")
```

3. **Chuyến bay được vận hành bởi United, American, hoặc Delta**
   - Gợi ý: Cần tra cứu mã hãng hàng không trong dataset `airlines`:
    - Kiểm tra bảng airlines trước
   airlines
    - lọc chuyến bay
  

```{r}
# 3. Chuyến bay của 3 hãng lớn: United, American, Delta
cat("3. Kiểm tra mã hãng hàng không:\n")
print(airlines)

# Tìm mã hãng
united_code <- airlines %>% filter(grepl("^United", name)) %>% pull(carrier)
american_code <- airlines %>% filter(grepl("^American", name)) %>% pull(carrier)
delta_code <- airlines %>% filter(grepl("^Delta", name)) %>% pull(carrier)

cat("United Airlines:", united_code, "\n")
cat("American Airlines:", american_code, "\n") 
cat("Delta Airlines:", delta_code, "\n")

flights_big3 <- flights %>% filter(carrier %in% c(united_code, american_code, delta_code))
cat("Số chuyến bay của 3 hãng :", nrow(flights_big3), "\n\n")
```

### **Câu hỏi tình huống**: Nếu một khách hàng muốn bay đến Houston và tránh các hãng có nhiều chuyến trễ, bạn sẽ khuyên gì dựa trên kết quả phân tích?

#### I. Khuyến nghị chính:
1. Lựa chọn hãng hàng không (theo thứ tự ưu tiên):
  - Nên chọn: Alaska Airlines (AS), JetBlue Airways (B6), hoặc American Airlines (AA)
  - Nên tránh: ExpressJet Airlines (EV) và Envoy Air (MQ) - thường có tỷ lệ trễ cao hơn

#### II. Thời điểm bay tối ưu:
  
 - Tốt nhất: Bay vào sáng sớm (6-8 giờ sáng)
 - Tránh: Các chuyến bay buổi tối (sau 18 giờ)

#### III. Lựa chọn sân bay:
 - Houston có 2 sân bay: IAH (Bush Intercontinental) và HOU (Hobby) 
 - Cần phân tích cụ thể để xác định sân bay nào có hiệu suất tốt hơn

#### IV. Đánh giá rủi ro:
- Tỷ lệ trễ ≥2 giờ tổng thể: 3.03% (tương đối thấp)
Với 931 chuyến bay đến Houston, khách hàng có 96.97% cơ hội không bị trễ quá 2 giờ

#### V. Lợi ích của việc chọn đúng:
- Có thể giảm 50-70% rủi ro bị trễ so với chọn ngẫu nhiên
- Tiết kiệm thời gian và giảm stress trong việc di chuyển
- Tăng khả năng bắt kịp các kết nối tiếp theo


### Bài tập 1.2: Phân tích theo mùa
#### **Tình huống**: Công ty du lịch muốn biết xu hướng độ trễ theo mùa để đưa ra khuyến nghị cho khách hàng.

1. **Chuyến bay trong mùa hè (tháng 6, 7, 8)**
   # Thử 3 cách khác nhau
   # Cách 1: between()
   # Cách 2: %in%
   # Cách 3: >= và <=

```{r}
# Tính tổng các Chuyến bay mùa hè - 3 cách khác nhau
cat("4. Chuyến bay mùa hè (tháng 6,7,8):\n")
```

```{r}
# Cách 1: sử dụng hàm between()
summer_flights_v1 <- flights %>% filter(between(month, 6, 8))
summer_flights_v1
```


```{r}
# Cách 2: Sử dụng biểu thức pipeline %in%
summer_flights_v2 <- filter(flights, month %in% c(6,7,8))
print(summer_flights_v2)
```


```{r}
# Cách 3: kết hợp biểu thức só sánh >= và <=
summer_flights_v3 <- flights %>% filter(month >= 6, month <= 8)
summer_flights_v3

```

#### Tính tổng các Chuyến bay mùa hè
     
```{r}
cat("Tính tổng các Chuyến bay mùa hè:","\n")
cat("Cách 1 (between):", nrow(summer_flights_v1), "chuyến\n")
cat("Cách 2 (%in%):", nrow(summer_flights_v2), "chuyến\n") 
cat("Cách 3 (>=, <=):", nrow(summer_flights_v3), "chuyến\n")
cat("Tất cả đều cho kết quả giống nhau:", 
    identical(summer_flights_v1, summer_flights_v2) && 
    identical(summer_flights_v2, summer_flights_v3), "\n\n")
```
2. **Chuyến bay đến muộn >2 giờ nhưng khởi hành đúng giờ**
   - Công thức logic: `arr_delay > 120 & dep_delay <= 0`
   
```{r}
cat("5. Chuyến bay đến muộn >2h nhưng khởi hành đúng giờ:\n")
late_arrival_ontime_dep <- filter(flights, arr_delay > 120, dep_delay <= 0)
cat("Số chuyến:", nrow(late_arrival_ontime_dep), "\n")
```

**Câu hỏi phân tích**: Tính xác suất một chuyến bay mùa hè bị trễ đến >2 giờ:

$$P(\text{trễ đến > 2h | mùa hè}) = \frac{\text{Số chuyến mùa hè trễ > 2h}}{\text{Tổng số chuyến mùa hè}}$$
```{r}
# Tính xác suất trễ đến >2h trong mùa hè
summer_late <- summer_flights_v1 %>% filter(arr_delay > 120) %>% nrow()
summer_total <- nrow(summer_flights_v1)
prob_summer_late <- summer_late / summer_total
cat("Xác suất trễ đến >2h trong mùa hè:", prob_summer_late, "\n")
cat("Tức là:", round(prob_summer_late * 100, 2), "%\n\n")
```


### Bài tập 1.3: Xử lý dữ liệu thiếu (Missing Values)
**Lý thuyết**: Trong R, giá trị thiếu được biểu diễn bằng `NA`. Các quy tắc logic:
- `NA & TRUE = NA`
- `NA | TRUE = TRUE`
- `NA & FALSE = FALSE`
- `NA | FALSE = NA`

**Câu hỏi**: Tại sao `NA ^ 0 = 1` và `NA * 0 = NaN`?
**Giải thích toán học**:
- Với mọi số thực x: $x^0 = 1$
- Nhưng $0 \times \infty$ và $0 \times (-\infty)$ là không xác định

```r
# Khám phá các trường hợp đặc biệt
NA ^ 0
NA | TRUE
NA & FALSE
NA * 0
```

**Bài tập thực hành**: Tìm và phân tích các chuyến bay bị hủy
- Tìm chuyến bay có dep_time bị thiếu
- Phân tích mối quan hệ với arr_time

```{r}
# Tìm chuyến bay bị hủy
cat("7. Chuyến bay bị hủy:\n")
cancelled_flights <- filter(flights, is.na(dep_time))
cat("Số chuyến bay bị hủy:", nrow(cancelled_flights), "\n")
```
```{r}
# Kiểm tra mối quan hệ với arr_time
cancelled_with_arr <- filter(cancelled_flights, !is.na(arr_time))
cat("Số chuyến bị hủy nhưng vẫn có arr_time:", nrow(cancelled_with_arr), "\n")
```

```{r}
# Thống kê missing values
cat("Thống kê giá trị thiếu:\n")
missing_summary <- flights %>% summarise(across(everything(), ~ sum(is.na(.)))) %>% pivot_longer(everything(), names_to = "column", values_to = "n_missing") %>% arrange(desc(n_missing))


print(missing_summary)
```

# ============================================================================
## Phần 2: Sắp xếp dữ liệu với arrange()

### Bài tập 2.1: Phân tích chuyến bay trễ nhất
#### **Tình huống**: Báo cáo cho ban lãnh đạo về tình trạng chuyến bay có vấn đề nghiêm trọng nhất.

1. **Tìm 10 chuyến bay trễ khởi hành nhất**
   -  Sắp xếp theo dep_delay giảm dần

```{r}
# 10 chuyến bay trễ khởi hành nhất
cat("1. Top 10 chuyến bay trễ khởi hành nhất:\n")
most_delayed <- flights %>% 
  filter(!is.na(dep_delay)) %>% 
  arrange(desc(dep_delay)) %>% 
  slice_head(n = 10)

print(most_delayed)
```


2. **Tìm chuyến bay khởi hành sớm nhất**
   - Sắp xếp theo dep_delay tăng dần
   
```{r}
# Chuyến bay khởi hành sớm nhất
cat("2. Top 10 chuyến bay khởi hành sớm nhất:\n")
earliest_flights <- flights %>% 
  filter(!is.na(dep_delay)) %>% 
  arrange(dep_delay) %>% 
  slice_head(n = 10)

print(earliest_flights)

```




**Câu hỏi phân tích**: 
- Chuyến bay trễ nhất trễ bao nhiêu giờ?
- Thời gian trễ này có ảnh hưởng như thế nào đến lịch trình ngày hôm sau?

Từ kết quả của bạn: trễ nhất = 1301 phút ≈ 21.68 giờ (HA 51, JFK→HNL).

Ảnh hưởng:
Đây là mức trễ gần 1 ngày, chắc chắn vỡ lịch chuỗi (aircraft rotation) và kế hoạch kíp bay ngày hôm sau.

Hệ quả thường thấy: đi muộn dây chuyền cho các chặng sau cùng tàu bay/crew, phải điều tàu bay khác, hoán chuyển tổ bay, tăng chi phí hãng và tăng rủi ro trễ cho nhiều chuyến tiếp theo.


```{r}
# Phân tích chuyến trễ nhất
max_delay <- flights %>% 
  filter(!is.na(dep_delay)) %>% 
  slice_max(dep_delay, n = 1, with_ties = FALSE)
cat("Chuyến bay trễ nhất:", paste(max_delay$carrier, max_delay$flight, paste0(max_delay$origin, "→", max_delay$dest)), "\n")
cat("Trễ:", max_delay$dep_delay, "phút =", max_delay$dep_delay, "phút =", round(max_delay$dep_delay / 60, 2), "giờ\n\n")
```

### Bài tập 2.2: Xử lý NA trong sắp xếp
#### **Vấn đề tình huống**: Mặc định `arrange()` đặt NA ở cuối.

```{r}
cat("3. Xử lý NA trong sắp xếp:\n")

# Mặc định: NA ở cuối
cat("Mặc định (NA ở cuối):\n")
default_arrange <- flights %>% arrange(dep_time)
default_arrange


```


- Đặt NA lên đầu: arrange(flights, desc(is.na(dep_time)), dep_time)

```{r}
# Đặt NA lên đầu
cat("NA lên đầu:\n")
na_first <- arrange(flights, desc(is.na(dep_time)), dep_time)
na_first
```


**Giải thích logic**: `desc(is.na(dep_time))` tạo ra TRUE/FALSE, và TRUE > FALSE nên NA được sắp xếp trước.

## Phần 3: Chọn cột với select()

### Bài tập 3.1: Tối ưu hóa báo cáo
#### **Tình huống**: Tạo báo cáo chỉ chứa thông tin cần thiết để tiết kiệm không gian và tăng tính đọc hiểu.

Hãy chọn các cột `dep_time`, `dep_delay`, `arr_time`, `arr_delay` bằng ít nhất 5 cách khác nhau:

- Cách 1: Liệt kê trực tiếp

- Cách 2: Sử dụng starts_with()

- Cách 3: Sử dụng matches() với regex

- Cách 4: Sử dụng all_of() với vector

- Cách 5: Sử dụng số thứ tự cột (không khuyến khích)

```{r}
# Cách 1: Liệt kê trực tiếp
method1 <- select(flights, dep_time, dep_delay, arr_time, arr_delay)
cat("Cách 1 - Liệt kê trực tiếp: ", ncol(method1), "cột\n")
method1
```


```{r}
# Cách 2: Sử dụng starts_with()
method2 <- select(flights, starts_with("dep_"), starts_with("arr_"))
cat("Cách 2 - starts_with(): ", ncol(method2), "cột\n")
method2
```

```{r}
# Cách 3: Sử dụng matches() với regex
method3 <- select(flights, matches("^(dep|arr)_(time|delay)$"))
cat("Cách 3 - matches() với regex: ", ncol(method3), "cột\n")
method3
```

```{r}
# Cách 4: Sử dụng all_of() với vector
time_vars <- c("dep_time", "dep_delay", "arr_time", "arr_delay")
method4 <- select(flights, all_of(time_vars))
cat("Cách 4 - all_of(): ", ncol(method4), "cột\n")
method4
```

```{r}
# Cách 5: Sử dụng số thứ tự (không dùng trong thực tế)
method5 <- select(flights, 4, 6, 7, 9)
cat("Cách 5 - Số thứ tự cột: ", ncol(method5), "cột\n")
method5
```

```{r}
# Kiểm tra kết quả 5 các cách
all_equal <- identical(method1, method2) && identical(method1, method3) && identical(method1, method4) && identical(method1, method5)
cat("Tất cả phương pháp cho kết quả giống nhau:", all_equal, "\n\n")
```


**Câu hỏi**: Tại sao không nên sử dụng số thứ tự cột?

```
Dễ vỡ khi schema thay đổi (thêm/bớt/cập nhật cột).

Khó đọc/khó bảo trì: người khác không biết cột 4,6,7,9 là gì.

Tên cột tự mô tả & bền vững hơn → nên dùng select() theo tên/helpers.
```

### Bài tập 3.2: Helper functions

Tìm hiểu các hàm hỗ trợ:

- `contains("TIME")`: tìm cột chứa "TIME"
- `ends_with("delay")`: tìm cột kết thúc bằng "delay"
- `everything()`: chọn tất cả các cột còn lại



```{r}
cat("2. Sử dụng  functions:\n")
# contains() - không phân biệt hoa thường mặc định
contains_time <- select(flights, contains("TIME"))
cat("contains('TIME') - tìm thấy", ncol(contains_time), "cột\n")

# contains() - phân biệt hoa thường
contains_time_case <- select(flights, contains("TIME", ignore.case = FALSE))
cat("contains('TIME', ignore.case = FALSE) - tìm thấy", ncol(contains_time_case), "cột\n")

# ends_with()
ends_delay <- select(flights, ends_with("delay"))
cat("ends_with('delay') - tìm thấy", ncol(ends_delay), "cột\n")

# Sắp xếp lại cột: đưa arr_delay lên đầu
rearranged <- select(flights, arr_delay, everything())
cat("Đưa arr_delay lên đầu, tổng cột:", ncol(rearranged), "\n\n")
```


## Phần 4: Tạo biến mới với mutate()

### Bài tập 4.1: Chuyển đổi thời gian
#### **Tình huống**: Hệ thống lưu trữ thời gian theo định dạng HHMM (ví dụ: 1504 = 15:04). Cần chuyển đổi thành phút từ nửa đêm để tính toán.

**Công thức chuyển đổi**:
```
Giờ = time %/% 100

Phút = time %% 100

Tổng phút từ nửa đêm = Giờ × 60 + Phút

```

**Xử lý trường hợp đặc biệt**: 2400 (nửa đêm) phải chuyển thành 0


```
# Viết hàm chuyển đổi
time2mins <- function(x) {
  (x %/% 100 * 60 + x %% 100) %% 1440
}

# Áp dụng cho dep_time và sched_dep_time
flights_times <- mutate(flights,
  dep_time_mins = time2mins(dep_time),
  sched_dep_time_mins = time2mins(sched_dep_time)
)
```


```{r}
#Ví dụ để Test đổi time
# hàm chuyển từ hhmm (kiểu số) sang phút tính từ 0h00
time2mins <- function(x) {
  # lấy phần giờ
  hours <- x %/% 100
  # lấy phần phút
  minutes <- x %% 100
  # tổng phút
  total_mins <- (hours * 60 + minutes) %% 1440
  return(total_mins)
}

# test
test_times <- c(1504, 2400, 0, 600)
cat("Test chuyển đổi:\n")
for(time in test_times) {
  mins <- time2mins(time)
  hours <- time %/% 100
  minutes <- time %% 100
  cat(sprintf("%04d -> %d phút = %02d:%02d\n", time, mins, hours, minutes))
}

```



```{r}
# Sử dụng cho toàn bộ dữ liệu
flights_times <- flights %>%
  mutate(dep_time_mins        = time2mins(dep_time),
    arr_time_mins        = time2mins(arr_time),
    sched_dep_time_mins  = time2mins(sched_dep_time),
    sched_arr_time_mins  = time2mins(sched_arr_time)
  )

cat("Đã chuyển đổi thành công!\n\n")
```


### Bài tập 4.2: Phân tích mối quan hệ thời gian bay
**Công thức kỳ vọng**: `air_time = arr_time - dep_time`

**Tình huống Thực tế như sau**:

1. **Múi giờ khác nhau**: Bay từ Đông sang Tây Hoa Kỳ

2. **Qua đêm**: Khởi hành trước nửa đêm, đến sau nửa đêm

3. **Thời gian lăn bánh**: `air_time` chỉ tính từ cất cánh đến hạ cánh

```
# Kiểm tra sự khác biệtthời gian
flights_airtime <- mutate(flights,
  dep_time_mins = time2mins(dep_time),
  arr_time_mins = time2mins(arr_time),
  air_time_diff = air_time - (arr_time_mins - dep_time_mins)
)

# Phân tích phân phối sự khác biệt nhau
ggplot(flights_airtime, aes(x = air_time_diff)) +
  geom_histogram(binwidth = 1)
```
```{r}


# Tính sự khác biệt
flights_airtime <- flights %>%
  mutate(
    dep_time_mins   = time2mins(dep_time),
    arr_time_mins   = time2mins(arr_time),
    flight_time_calc = arr_time_mins - dep_time_mins,
    # Xử lý trường hợp qua đêm (arr_time < dep_time)
    flight_time_calc = ifelse(arr_time_mins < dep_time_mins, 
                             flight_time_calc + 1440, 
                             flight_time_calc),
    air_time_diff = air_time - flight_time_calc) %>%
  filter(!is.na(air_time), !is.na(air_time_diff))
flights_airtime

```

```{r}
# Thống kê sự khác biệt
diff_summary <- flights_airtime %>%
  summarise(
    n          = n(),
    mean_diff  = mean(air_time_diff, na.rm = TRUE),
    median_diff= median(air_time_diff, na.rm = TRUE),
    sd_diff    = sd(air_time_diff, na.rm = TRUE),
    min_diff   = min(air_time_diff, na.rm = TRUE),
    max_diff   = max(air_time_diff, na.rm = TRUE)
  )

print(diff_summary)
```


```{r}
cat("2. Phân tích air_time vs (arr_time - dep_time):\n")

# Phân tích các chuyến bay có sự khác biệt = 0
exact_match <- flights_airtime %>%
  filter(air_time_diff == 0) %>%
  nrow()

cat("Số chuyến bay có air_time = arr_time - dep_time:", exact_match, "\n")
cat("Tỷ lệ:", round(exact_match/nrow(flights_airtime)*100, 2), "%\n\n")
```

#### **Câu hỏi phân tích**: Tại sao `air_time_diff` có các đỉnh tại bội số của 60?

```
Lịch block time (thời gian “kế hoạch” từ đẩy bánh → chạm bánh) thường được làm tròn theo giờ hoặc “giờ + 30 phút”.

Dữ liệu thực tế có làm tròn phút / quy ước hhmm, cộng với xử lý qua đêm → sai khác giữa air_time và (arr_time - dep_time) thường dồn quanh 60, 120, 180… phút (bội số của 60).
```

### Bài tập 4.3: Ranking và xử lý xếp hạng
**Tình huống**: Xếp hạng 10 chuyến bay trễ nhất cho báo cáo quản lý.

**So sánh các hàm ranking**:
- `row_number()`: mỗi phần tử có rank duy nhất
- `min_rank()`: ties có cùng rank, rank tiếp theo bỏ qua
- `dense_rank()`: ties có cùng rank, rank tiếp theo liên tiếp

```
# Demo với dữ liệu mẫu
rankme <- tibble(x = c(10, 5, 1, 5, 5))
mutate(rankme,
  row_num = row_number(x),
  min_rnk = min_rank(x),
  dense_rnk = dense_rank(x)
)
```

```{r}
cat("3. So sánh các hàm ranking:\n")

# Test xếp hạng với dự liệu mẫu
rankme <- tibble(x = c(10, 5, 1, 5, 5))
rank_demo <- rankme %>%
  mutate(
    row_num  = dplyr::row_number(x),
    min_rnk  = dplyr::min_rank(x), 
    dense_rnk= dplyr::dense_rank(x)
  ) %>%
  arrange(x)

print(rank_demo)
```




#### **Bài tập**: Tìm 10 chuyến bay trễ nhất và so sánh kết quả của các hàm ranking.

```{r}
# Tìm 10 chuyến bay trễ nhất
cat("Top 10 chuyến bay trễ nhất:\n")
top10_delayed <- flights %>%
  mutate(
    dep_delay_min_rank   = min_rank(desc(dep_delay)),
    dep_delay_row_number = row_number(desc(dep_delay)),
    dep_delay_dense_rank = dense_rank(desc(dep_delay))
  ) %>%
  filter(dep_delay_min_rank <= 10)

print(top10_delayed)
```

## Phần 5: Tóm tắt theo nhóm dùng summarise() và group_by()

### Bài tập 5.1: Đánh giá đặc điểm trễ chuyến bay
#### **Tình huống**: Khách hàng hỏi "Hãng nào tốt nhất?" 
- cần các chỉ số đánh giá khác nhau.

**Các scenarios để phân tích**:
1. Chuyến bay sớm 15 phút 50% thời gian, trễ 15 phút 50% thời gian
2. Chuyến bay luôn trễ 10 phút
3. Chuyến bay sớm 30 phút 50% thời gian, trễ 30 phút 50% thời gian
4. 99% đúng giờ, 1% trễ 2 tiếng

**Các chỉ số đánh giá**:
- Trung bình: $\bar{x} = \frac{\sum x_i}{n}$
- Trung vị: giá trị ở vị trí 50%
- Độ biến thiên: $\sigma = \sqrt{\frac{\sum (x_i - \bar{x})^2}{n-1}}$
- Tỷ lệ đúng giờ: $P(\text{delay} \leq 0)$

```
# Phân tích theo hãng hàng không
flights %>%
  group_by(carrier) %>%
  summarise(
    count = n(),
    mean_delay = mean(arr_delay, na.rm = TRUE),
    median_delay = median(arr_delay, na.rm = TRUE),
    sd_delay = sd(arr_delay, na.rm = TRUE),
    on_time_rate = mean(arr_delay <= 0, na.rm = TRUE)
  ) %>%
  arrange(desc(mean_delay))
```


```{r}
cat("1. Phân tích độ trễ theo hãng hàng không:\n")

carrier_performance <- flights %>%
  filter(!is.na(arr_delay)) %>%
  group_by(carrier) %>%
  summarise(
    flights_count = n(),
    mean_delay      = mean(arr_delay, na.rm = TRUE),
    median_delay    = median(arr_delay, na.rm = TRUE),
    sd_delay        = sd(arr_delay, na.rm = TRUE),
    on_time_rate    = mean(arr_delay <= 0, na.rm = TRUE),
    very_late_rate  = mean(arr_delay > 120, na.rm = TRUE),  # >2h
    .groups = 'drop'
  ) %>%
  arrange(desc(mean_delay)) %>%
  # Thêm tên hãng
  left_join(airlines, by = "carrier")

print(carrier_performance)
```

```{r}
# Tìm hãng tốt nhất và tệ nhất
best_carrier <- carrier_performance %>%
  filter(flights_count >= 1000) %>%  # Chỉ xem xét hãng có đủ chuyến bay
  slice_min(mean_delay, n = 1)

worst_carrier <- carrier_performance %>%
  filter(flights_count >= 1000) %>%
  slice_max(mean_delay, n = 1)

cat("Hãng tốt nhất (ít trễ nhất):", best_carrier$name, 
    "- Trễ TB:", round(best_carrier$mean_delay, 1), "phút\n")
cat("Hãng tệ nhất (trễ nhiều nhất):", worst_carrier$name,
    "- Trễ TB:", round(worst_carrier$mean_delay, 1), "phút\n\n")
```


### Bài tập 5.2: Phân tích tương quan thời gian
**Giả thuyết**: Chuyến bay trễ có xu hướng làm các chuyến bay sau cũng bị trễ.

**Công thức correlation**:
$$r = \frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sqrt{\sum (x_i - \bar{x})^2 \sum (y_i - \bar{y})^2}}$$

```
# Phân tích lag correlation
lagged_delays <- flights %>%
  arrange(origin, month, day, dep_time) %>%
  group_by(origin) %>%
  mutate(dep_delay_lag = lag(dep_delay)) %>%
  filter(!is.na(dep_delay), !is.na(dep_delay_lag))

# Vẽ biểu đồ scatter
ggplot(lagged_delays, aes(x = dep_delay_lag, y = dep_delay)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm")
```

```{r}
# 2. Phân tích lag correlation (ảnh hưởng chuyến bay trước)

lagged_delays <- flights %>%
  filter(!is.na(dep_delay)) %>%
  arrange(year, month, day, dep_time) %>%
  group_by(origin) %>%
  mutate(dep_delay_lag  = lag(dep_delay)) %>%
  filter(!is.na(dep_delay_lag)) %>%
  ungroup()
print(lagged_delays)
```


```{r}
# Tính correlation
correlation <- cor(lagged_delays$dep_delay_lag, lagged_delays$dep_delay)
cat("Correlation giữa chuyến bay hiện tại và chuyến trước:", round(correlation, 3), "\n")
```
```{r}
# Phân tích theo nhóm độ trễ
lag_analysis <- lagged_delays %>%
  mutate(
    lag_delay_group = case_when(
      dep_delay_lag <= 0 ~ "Đúng giờ/Sớm",
      dep_delay_lag <= 30 ~ "Trễ ít (≤30p)", 
      dep_delay_lag <= 120 ~ "Trễ vừa (30-120p)",
      TRUE ~ "Trễ nhiều (>120p)"
    )
  ) %>%
  group_by(lag_delay_group) %>%
  summarise(
    count = n(),
    mean_current_delay = mean(dep_delay, na.rm = TRUE),
    .groups = 'drop'
  )

print(lag_analysis)
```




### Bài tập 5.3: Phát hiện anomaly
**Mục tiêu**: Tìm các chuyến bay có thời gian bay "đáng ngờ" (quá nhanh hoặc quá chậm).

**Phương pháp standardization**:
$$z = \frac{x - \mu}{\sigma}$$

Chuyến bay có |z| > 3 được coi là outlier.

```
# Chuẩn hóa thời gian bay theo route
standardized_flights <- flights %>%
  filter(!is.na(air_time)) %>%
  group_by(dest, origin) %>%
  mutate(
    air_time_mean = mean(air_time),
    air_time_sd = sd(air_time),
    air_time_z = (air_time - air_time_mean) / air_time_sd
  )

# Tìm outliers
extreme_flights <- standardized_flights %>%
  filter(abs(air_time_z) > 3) %>%
  arrange(air_time_z)
```

```{r}
# 3. Phát hiện chuyến bay có thời gian bay bất thường:
# Chuẩn hóa thời gian bay theo route
standardized_flights <- flights %>%
  filter(!is.na(air_time)) %>%
  group_by(origin, dest) %>%
  mutate(
    route_flights = n(),
    air_time_mean = mean(air_time),
    air_time_sd = sd(air_time),
    air_time_z = (air_time - air_time_mean) / if_else(air_time_sd == 0, 1, air_time_sd)
  ) %>%  # +1 tránh chia 0
  filter(route_flights >= 10) %>%  # Chỉ xét route có đủ chuyến bay
  ungroup()
```

```{r}
# Xem 6 dòng đầu
head(standardized_flights)
```

```{r}
# in toàn bộ
print(standardized_flights)
```


```{r}

# xem cấu trúc
str(standardized_flights)
```



```{r}
# Tìm outliers (|z| > 3)
extreme_flights <- standardized_flights  %>%
  filter(abs(air_time_z) > 3) %>%
  arrange(desc(abs(air_time_z))) %>%
  mutate(
    ground_speed_mph = distance / (air_time / 60)
  ) %>%
  select(carrier, flight, origin, dest, air_time, air_time_mean, 
         air_time_z, ground_speed_mph)

cat("Chuyến bay có thời gian bất thường (|z-score| > 3):\n")
print(head(extreme_flights, 10))
```


```{r}
# Phân tích tốc độ
speed_analysis <- flights %>%
  filter(!is.na(air_time), air_time > 0, !is.na(distance)) %>%
  mutate(ground_speed_mph = distance / (air_time / 60)) %>%
  summarise(
    count        = n(),
    mean_speed   = mean(ground_speed_mph, na.rm = TRUE),
    median_speed = median(ground_speed_mph, na.rm = TRUE), 
    max_speed    = max(ground_speed_mph, na.rm = TRUE),
    over_600mph  = sum(ground_speed_mph > 600, na.rm = TRUE),
    over_700mph  = sum(ground_speed_mph > 700, na.rm = TRUE)
  )

print(speed_analysis)

```


```
max_speed = 703.3846 mph.

Đổi sang km/h:

703.3846 mph×1.609344=1132.47 km/h

Tốc độ tối đa ghi nhận trong các chuyến bay:: khoảng 1132 km/h

Kiến thức bổ sung: Máy bay thương mại thường bay với tốc độ 850-950 km/h. Gió thuận có thể tăng tốc độ ground speed lên 1200+ km/h.(chatGPT hoặc tìm kiếm thông tin trên gooogle)

```

#### **Câu hỏi phân tích**: 
1. Chuyến bay nhanh nhất có thể đạt tốc độ bao nhiêu km/h?
2. Tốc độ này có hợp lý không với máy bay thương mại?

Kết quả của bạn: max ground speed = 703.3846 mph ≈ 1132.47 km/h.

Có hợp lý không?

Ground speed (tốc độ so với mặt đất) có thể vượt tốc độ hành trình điển hình (850–950 km/h) nhờ gió đuôi/jet stream → hoàn toàn hợp lý khi gặp dòng gió mạnh.

Lưu ý: airspeed (tốc độ so với không khí) của máy bay thương mại vẫn trong khoảng an toàn; ground speed cao không đồng nghĩa máy bay “bay quá nhanh” so với giới hạn thiết kế.

## Bài tập tổng hợp

### Phân tích hiệu suất sân bay
**Tình huống**: Bạn được yêu cầu tư vấn cho một hãng hàng không về việc chọn sân bay hub.

1. **Tính toán chỉ số hiệu suất cho mỗi sân bay đến**:
   - Số chuyến bay trung bình mỗi ngày
   - Tỷ lệ chuyến bay bị hủy
   - Độ trễ trung bình
   - Độ biến thiên của độ trễ
   
```{r}
cat("1. Phân tích hiệu suất sân bay đến:\n")

airport_performance <- flights %>%
  group_by(dest) %>%
  summarise(
    flights_per_day   = n() / n_distinct(year, month, day),  # Trung bình mỗi ngày
    cancellation_rate = mean(is.na(dep_time)),
    mean_arr_delay    = mean(arr_delay, na.rm = TRUE),
    median_arr_delay  = median(arr_delay, na.rm = TRUE),
    delay_variability = sd(arr_delay, na.rm = TRUE),
    on_time_rate      = mean(arr_delay <= 0, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  filter(flights_per_day >= 1) %>%  # Ít nhất 1 chuyến/ngày
  arrange(mean_arr_delay)

print(head(airport_performance, 10))

```


2. **Phân tích theo thời gian**:
   - Giờ bay tốt nhất trong ngày (ít trễ nhất)
   - Tháng có hiệu suất tốt nhất
   
```{r}
cat("2. Thời gian bay tốt nhất trong ngày:\n")

hourly_performance <- flights %>%
  filter(!is.na(dep_delay), !is.na(hour)) %>%
  group_by(hour) %>%
  summarise(
    flights_count = n(),
    mean_dep_delay = mean(dep_delay),
    on_time_rate = mean(dep_delay <= 0),
    .groups = 'drop'
  ) %>%
  arrange(mean_dep_delay)

print(hourly_performance)

best_hour <- hourly_performance   %>%
  filter(flights_count >= 1000) %>%
  slice_min(mean_dep_delay, n = 1)

cat("Giờ bay tốt nhất:", best_hour$hour, "giờ - Trễ TB:", 
    round(best_hour$mean_dep_delay, 1), "phút\n")

```


```{r}
cat("2b. Tháng có hiệu suất tốt nhất:\n")

monthly_performance <- flights %>%
  filter(!is.na(dep_delay), !is.na(month)) %>%
  group_by(month) %>%
  summarise(
    flights_count = n(),
    mean_dep_delay = mean(dep_delay),
    on_time_rate = mean(dep_delay <= 0),
    .groups = 'drop'
  ) %>%
  arrange(mean_dep_delay)

print(monthly_performance)

best_month <- monthly_performance %>%
  filter(flights_count >= 1000) %>%    # tránh tháng ít chuyến
  slice_min(mean_dep_delay, n = 1)

cat("Tháng bay tốt nhất:", best_month$month,
    "- Trễ TB:", round(best_month$mean_dep_delay, 1), "phút\n")

```


3. **So sánh giữa các hãng**:
   - Hãng nào có hiệu suất tốt nhất trên cùng một route?
   - Tách biệt được yếu tố sân bay và yếu tố hãng hàng không không?

**Deliverable**: Một báo cáo hoàn chỉnh với visualizations và recommendations.

```{r}
cat("3. Hiệu suất từng hãng bay vs sân bay:\n")

route_carrier_analysis <- flights %>%
  filter(!is.na(arr_delay)) %>%
  group_by(origin, dest, carrier) %>%
  summarise(
    flights = n(),
    carrier_delay = mean(arr_delay),
    .groups = 'drop'
  ) %>%
  filter(flights >= 10) %>%  # Đủ chuyến bay để phân tích
  group_by(origin, dest) %>%
  mutate(
    route_delay = mean(carrier_delay),  # Trễ trung bình của route
    carrier_effect = carrier_delay - route_delay  # Hiệu ứng riêng của hãng
  ) %>%
  ungroup()

# Xếp hạng hãng theo hiệu ứng trung bình
carrier_ranking <- route_carrier_analysis %>%
  group_by(carrier) %>%
  summarise(
    routes_served = n(),
    avg_carrier_effect = mean(carrier_effect),
    .groups = 'drop'
  ) %>%
  filter(routes_served >= 10) %>%
  arrange(avg_carrier_effect) %>%
  left_join(airlines, by = "carrier")

print(carrier_ranking)
```




### Mô hình dự đoán logistic
**Challenge**: Xây dựng một mô logistic giản để dự đoán xác suất một chuyến bay sẽ bị trễ dựa trên:
- Giờ khởi hành dự kiến
- Hãng hàng không  
- Sân bay đến
- Tháng trong năm

```
# Tạo model logistic
delay_model <- flights %>%
  mutate(is_delayed = arr_delay > 15) %>%
  glm(is_delayed ~ hour + carrier + dest + month, 
      data = ., family = binomial)

summary(delay_model)

```

#### 4. Mô hình dự đoán xác suất trễ >15 phút:
```{r}
# Chuẩn bị dữ liệu cho mô hình
model_data <- flights %>%
  filter(!is.na(arr_delay), !is.na(hour)) %>%
  mutate(
    is_delayed = as.integer(arr_delay > 15),
    season = case_when(
      month %in% c(12, 1, 2) ~ "Winter",
      month %in% c(3, 4, 5) ~ "Spring", 
      month %in% c(6, 7, 8) ~ "Summer",
      TRUE ~ "Fall"
    )
  ) %>%
  # Chỉ giữ các hãng và sân bay chính
  group_by(carrier) %>%
  filter(n() >= 1000) %>%
  ungroup() %>%
  group_by(dest) %>%
  filter(n() >= 1000) %>%
  ungroup()
```


```{r}
# Tính tỷ lệ trễ theo từng yếu tố
delay_rates <- list(
  by_hour = model_data %>%
    group_by(hour) %>%
    summarise(delay_rate = mean(is_delayed), groups = 'drop'),
  
  by_carrier = model_data %>%
    group_by(carrier) %>% 
    summarise(delay_rate = mean(is_delayed), groups = 'drop'),
  
  by_dest = model_data %>%
    group_by(dest) %>%
    summarise(delay_rate = mean(is_delayed), groups = 'drop'),
    
  by_season = model_data %>%
    group_by(season) %>%
    summarise(delay_rate = mean(is_delayed), groups = 'drop')
)

# In ra kết quả
cat("Tỷ lệ trễ theo giờ bay:\n")
print(delay_rates$by_hour)

cat("\nTỷ lệ trễ theo hãng bay:\n")
print(delay_rates$by_carrier)

cat("\nTỷ lệ trễ theo sân bay đích (dest):\n")
print(delay_rates$by_dest)

cat("\nTỷ lệ trễ theo mùa (season):\n")
print(delay_rates$by_season)

```

#### KẾT QUẢ CỦA MÔ HÌNH
```{r}
# In kết quả
cat("Tỷ lệ trễ >15p theo giờ (top 5 tốt nhất và tệ nhất):\n")
print(rbind(head(delay_rates$by_hour, 5), tail(delay_rates$by_hour, 5)))

cat("Tỷ lệ trễ theo hãng:\n")  
print(arrange(delay_rates$by_carrier, delay_rate))

cat("Tỷ lệ trễ theo mùa:\n")
print(arrange(delay_rates$by_season, delay_rate))

# Tổng kết và khuyến nghị
cat("\n=== TỔNG KẾT VÀ KHUYẾN NGHỊ ===\n")
```
#### KẾT QUẢ PHÂN TÍCH CHÍNH

```{r}
cat("KẾT QUẢ PHÂN TÍCH CHÍNH:\n")
cat("1. Hãng hàng không tốt nhất:", best_carrier$name, "\n")
cat("2. Giờ bay tốt nhất:", best_hour$hour, "giờ sáng\n") 
cat("3. Mùa ít trễ nhất:", delay_rates$by_season$season[1], "\n")
cat("4. Correlation chuyến bay liên tiếp:", round(correlation, 3), "\n")
```
#### KHUYẾN NGHỊ CHO KHÁCH HÀNG

```{r}
cat("KHUYẾN NGHỊ CHO KHÁCH HÀNG:\n")
cat("- Bay vào buổi sáng sớm (6-8 giờ) để tránh trễ\n")
cat("- Chọn hãng có hiệu suất tốt cho route cụ thể\n") 
cat("- Tránh bay trong mùa hè nếu có thể\n")
cat("- Dự phòng thời gian cho các chuyến bay chiều/tối\n\n")
```

**Câu hỏi**: Làm sao đánh giá độ chính xác của mô hình này?
1 - Tách dữ liệu: Train/validation/test (ví dụ 70/15/15) hoặc k-fold CV (5/10-fold).

2 - Ma trận nhầm lẫn (ở ngưỡng 0.5 hoặc tối ưu theo mục tiêu):

Accuracy, Precision, Recall, F1.

Chú ý class imbalance (tỉ lệ trễ >15p không quá lớn) → đừng chỉ nhìn accuracy.

3 - AUC-ROC & PR-AUC:

ROC-AUC đo phân biệt tổng quát;

PR-AUC phù hợp hơn khi lớp “trễ” là thiểu số.

4 - Hiệu chỉnh xác suất (Calibration):

Brier score, calibration curve (độ tin cậy của xác suất dự đoán).

5 - Độ ổn định/tổng quát hóa:

Cross-validation, time-split (nếu dữ liệu theo thời gian) để kiểm tra drift.

6 - So sánh baseline:

So với mô hình đơn giản (ví dụ dự đoán theo tỷ lệ trễ 

7 - Phân tích đặc trưng:

Pseudo- R3 (McFadden), LR test, AIC/BIC để so sánh đặc trưng;

VIF/tương quan để tránh đa cộng tuyến; regularization (L1/L2) nếu cần.

8 - Đánh giá theo nhóm:

Chấm theo hour, carrier, dest, season để phát hiện bias/khu vực mô hình yếu.
```{r}
# CODE THÊM — Đánh giá độ chính xác mô hình logistic

# ==== 0) Thư viện cần dùng (có thể cài nếu thiếu) ====
# install.packages(c("pROC","PRROC"))
library(dplyr)
library(pROC)
library(PRROC)

# ==== 1) Chuẩn bị dữ liệu (tái sử dụng nếu model_data đã được tạo ở trên) ====
if (!exists("model_data")) {
  model_data <- flights %>%
    dplyr::filter(!is.na(arr_delay), !is.na(hour)) %>%
    dplyr::mutate(
      is_delayed = as.integer(arr_delay > 15),
      season = dplyr::case_when(
        month %in% c(12, 1, 2) ~ "Winter",
        month %in% c(3, 4, 5) ~ "Spring", 
        month %in% c(6, 7, 8) ~ "Summer",
        TRUE ~ "Fall"
      )
    ) %>%
    # Chỉ giữ hãng/sân bay có đủ quan sát
    dplyr::group_by(carrier) %>% dplyr::filter(dplyr::n() >= 1000) %>% dplyr::ungroup() %>%
    dplyr::group_by(dest)    %>% dplyr::filter(dplyr::n() >= 1000) %>% dplyr::ungroup()
}

# ==== 2) Chia tập train/test (80/20) ====
set.seed(42)  # cố định để tái lập
n <- nrow(model_data)
idx_train <- sample.int(n, size = floor(0.8 * n))
train <- model_data[idx_train, ]
test  <- model_data[-idx_train, ]

# ==== 3) Huấn luyện mô hình logistic trên tập train ====
model_glm <- glm(
  is_delayed ~ hour + carrier + dest + month,
  data = train,
  family = binomial()
)

# ==== 4) Dự đoán xác suất trên tập test ====
test$prob <- predict(model_glm, newdata = test, type = "response")

# ==== 5) ROC & AUC; chọn ngưỡng tốt theo Youden J ====
roc_obj <- pROC::roc(response = test$is_delayed, predictor = test$prob)
auc_roc <- pROC::auc(roc_obj)
best_thr <- as.numeric(pROC::coords(roc_obj, "best", best.method = "youden")["threshold"])

cat(sprintf("ROC-AUC = %.3f\n", auc_roc))
cat(sprintf("Ngưỡng tốt (Youden J) = %.3f\n", best_thr))

# ==== 6) Ma trận nhầm lẫn & các chỉ số ở 2 ngưỡng (0.5 và best_thr) ====
metrics_at_threshold <- function(thr, y_true, y_prob) {
  y_pred <- ifelse(y_prob >= thr, 1L, 0L)
  TP <- sum(y_pred == 1 & y_true == 1)
  TN <- sum(y_pred == 0 & y_true == 0)
  FP <- sum(y_pred == 1 & y_true == 0)
  FN <- sum(y_pred == 0 & y_true == 1)
  acc <- (TP + TN) / (TP + TN + FP + FN)
  prec <- ifelse((TP + FP) == 0, NA_real_, TP / (TP + FP))
  rec  <- ifelse((TP + FN) == 0, NA_real_, TP / (TP + FN))
  f1   <- ifelse(is.na(prec) || is.na(rec) || (prec + rec) == 0, NA_real_, 2 * prec * rec / (prec + rec))
  list(threshold = thr, TP = TP, TN = TN, FP = FP, FN = FN,
       accuracy = acc, precision = prec, recall = rec, F1 = f1)
}

m05  <- metrics_at_threshold(0.5,  test$is_delayed, test$prob)
mbst <- metrics_at_threshold(best_thr, test$is_delayed, test$prob)

cat("\n== Chỉ số ở ngưỡng 0.5 ==\n")
print(m05)

cat("\n== Chỉ số ở ngưỡng tối ưu (Youden J) ==\n")
print(mbst)

# ==== 7) PR AUC (Precision-Recall) ====
# PRROC yêu cầu truyền điểm dự đoán cho lớp dương và âm riêng biệt
pos_scores <- test$prob[test$is_delayed == 1]
neg_scores <- test$prob[test$is_delayed == 0]
pr_obj <- PRROC::pr.curve(scores.class0 = pos_scores, scores.class1 = neg_scores, curve = TRUE)
auc_pr <- pr_obj$auc.integral
cat(sprintf("\nPR-AUC = %.3f\n", auc_pr))

# ==== 8) Brier score (độ hiệu chỉnh xác suất) ====
brier <- mean((test$prob - test$is_delayed)^2)
cat(sprintf("Brier score = %.4f (càng nhỏ càng tốt)\n", brier))

# ==== 9) Bảng hiệu chỉnh (calibration) theo decile xác suất ====
calib_table <- test %>%
  dplyr::mutate(bin = ntile(prob, 10)) %>%
  dplyr::group_by(bin) %>%
  dplyr::summarise(
    n = dplyr::n(),
    mean_pred_prob = mean(prob),
    observed_rate  = mean(is_delayed)
  ) %>%
  dplyr::arrange(bin)

cat("\n== Bảng hiệu chỉnh theo decile xác suất ==\n")
print(calib_table)

```


## Tài liệu tham khảo
- R for Data Science: https://r4ds.had.co.nz/
- dplyr documentation: https://dplyr.tidyverse.org/
- Bureau of Transportation Statistics: https://www.transtats.bts.gov/



